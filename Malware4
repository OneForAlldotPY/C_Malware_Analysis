//* Simple Buffer Overflow

#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[50];
    strcpy(buffer, input);
    printf("You entered: %s\n", buffer);
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    vulnerable_function(argv[1]);
    return 0;
}



/* Q&A - Simple Buffer Overflow structure

1 - What is the purpose of the vulnerable_function, and how does it work?

    The vulnerable_function takes an input provided from the user, copies it into a local buffer of fixed size of 50 characters 
    and then prints the size of the buffer. It used strcpy to copy the value from the input to the buffer.

2 - What potential security vulnerability exists in this code?

    Due to the lack of restriction of the input the code is likely vulnerable to a buffer overflow

3 - How can an attacker exploit the identified vulnerability?

    An attacker can exploit the identified vulnerability by inputing a value higher than the defined in the code

4 - What is the role of the strcpy function in this vulnerability?

    The strcpy copies the entire input from the user into the buffer without checking if the buffer is large enough 
    to hold/get the input. That makes the strcpy the main reason and the center of the vulnerability in this code

5 - Suggest potential improvements or mitigations to secure the code.

    The code should handle/sanitize the input before processing it and use strncpy or snprintf instead of strcpy as they allow 
    to define the maximum size to copy an example can be: 
    
    strncpy(buffer, input, sizeof(buffer)-1);
    buffer[sizeof(buffer) - 1 ] = '\0';
    .
    .
    .

*/